Rank : 5321 / 13805

1.
第一題很簡單，先把新的矩陣開好，之後就按照順序填就好，沒甚麼特別的細節
複雜度O(n)

2.
這次的比賽完全被這一題害死...一開始看到題目就知道有個O(nlogn) sort兩次的解法
但想說可以寫個用heap的方法，這樣第二輪的複雜度可以降成O(nlogk)
結果比賽的時候各種超時...還沒有告訴我是哪個測資超時，最後改用複雜度差的方式傳就過了
比賽後又傳了一次，結果就過了，速度還比我比賽用的方法更快... what the fuck...
反正解法就是先sort找出median，然後再照題目給的方式sort，最後取前k個，超簡單- -
複雜度O(nlogn)，n為陣列的長度

3.
第三題寫了一陣子，看到題目的時候就知道要用doubly linked list，只是對c++的list很不熟，邊寫邊看了api
首先我們先初始化list，放進去首頁，並存一個目前位置的iterator now
對於visit，我們先用另一個iterator指到now下一格，並把從這格開始到end全都刪掉
之後push back下一個url，而now就可以改指為新的url
而back就直接操作now，特別注意如果now已經為begin，就不能再--
而forward對於每一步先看下一個位置是不是end，如果是就不能再往後，否則就一直++
對於每一個函數的複雜度基本上worst case都是O(n)

4.
第四題看到就知道dp，但比賽時因為第二題直接崩潰不想想
看了下別人的解法，dp是標準解，但我覺得這題top-down的解法很容易理解，而且寫起來也很精簡
top-down的解法就是基本的遞迴，加上cache，確保同樣的組合只會走一次
現在定義dfs(h, target, color)為塗第h個房子，還要塗成target個鄰居，再加上前一個房子的顏色是color
所以初始dfs為dfs(0, target, 0)，用0是因為顏色是從1開始，保證不會撞
遞迴的特判條件有三種，第一種是房子到底或是target小於0(不能是等於0，因為等於0可能還可以繼續塗色，只要跟前一個同色就好)
這種情況就看房子是不是剛好到底且target為0，是就return 0，代表base case，不然就return一個很大的數字
第二種條件是房子塗過，那就直接跑到下一個房子，且檢查一下這個房子的顏色和上一個是否相同
第三種是cache裡有了，那就直接return
如果不是上述三種，那就直接暴搜所有顏色，都塗看看，找到cost最小的，再把答案放在cache中
最後就檢查dfs的回傳值是不是很大的數字，不是就可以直接回傳，不然就回傳-1
複雜度為O(mnt*n)，我覺得這題是用來練習top-down非常好的題目，比賽的時候不用這麼糾結一定要用dp
