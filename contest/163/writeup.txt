Rank : x / x

1.
直接用shift算新的陣列第一格從舊的哪裡開始，之後一直往後取就好
一開始算shift k花了一點時間
複雜度O(mn)，m和n為矩陣的長寬

2.
第二題比賽的時候寫了一個O(n)的做法，第一次超時，第二次優化了一下過了
但我知道正解應該是O(logn)，也應該用2進位來看，但比賽的時候沒想到
最後的方法是把新的樹改成以1為root，而不要用題目的0為root，這樣就解決了
因為原本的root為0沒辦法用binary來解，改成用1的話，扣除掉第一位，之後只要是0就走左，1就走右
所以一開始先把tree重新填值，從1開始，左邊為root*2，右邊為root*2+1
之後的查找，我先用一個stack把數字+1做分解並拿掉第一位，之後就看，如果是0且沒有左子樹，或是為1且沒有右子樹，則直接return false，代表想要的值不存在
不然就一直走到stack為空，如果可以就return true
初始化複雜度O(n)，查找複雜度基本為(logn)，n為節點個數，但如果是imbalanced tree，則可能退化為O(n)

3.
第三題直接greedy，先把所有數字相加，並把除以3餘1和2的數字分別拿出來
先把這兩個vector sort一下，從小排到大
之後我們就看總和，如果已經是3的倍數，可以直接return
如果是餘1，代表我們可能有一個餘1或是兩個餘2的數字，那我們就看，如果兩種都有，就扣掉數字和小的那個，否則就扣掉其中一種
如果是餘2，代表我們可能有兩個餘1或是一個餘2的數字，再按照上面的邏輯一樣處理
最後的sum就是答案
複雜度O(nlogn)，來自於sort，之後的判斷為O(1)

4.
第四題WA，知道要用dfs和bfs，但原本的寫法有沒涵蓋的測資
看解法要用雙層bfs，太複雜放棄...
