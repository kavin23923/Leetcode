Rank : x / x

1.
第一題暴力解寫老半天...後兩題medium寫完還比寫這一題快...
直接開一個3*3矩陣，初始為0，先把input陣列填進去，用1和-1代表兩個人走過的位置
之後直接判斷有沒有贏家，方法是直接窮舉贏的8種可能，且特別指定要是1或-1
如果沒有贏家，就看input的數量是不是填滿了整個矩陣，是就是draw，否則就是pending
複雜度O(1)，因為input其實最多就是9格，且判斷贏家的方式跟input數量沒關係

2.
第二題直接解聯立，列式子花了一點時間XD
先特判一下tomatoSlices，這個東西必須要是偶數，如果是奇數直接return
之後就看聯立解的答案是不是都大於0就好
複雜度O(1)

3.
第三題也是很簡單的dp，dp[i][j]代表以i row, j col為底，最大的正方形邊長為多少
如果當前的格子是0就不理，如果是1就更新dp，且累加答案當前dp的值(因為可以多1*1~邊長*邊長這麼多種答案)
複雜度O(mn)，m和n是原矩陣的大小

4.
第四題一看就是dp，寫了我50分鐘，最後總算搞出來...
先計算一個矩陣cost[i][j]，代表第i~j個char要變成Palindrome的cost
之後就是真正的dp，dp[i][j]代表我使用前i個char，切割成j個子字串需要的最小cost
則遞迴式為，dp[i][j] = min(dp[a][j - 1] + cost[a][i - 1])，a從0到i - 1
其中當j > i時不用填，因為只用i個char沒辦法切成j個
最後花了很多時間debug初始化的地方，在這裡dp都先初始化為一個很大的數
且只再初始化dp[0][0] = 0，因為當第一個維度不是0時，都不可能切割成0份，而其他沒有填到的部分代表不可能
複雜度O(n^3 + n^2*k)，n是字串長度，一開始cost隨便寫了一個三次方的方法，之後就是dp填表
