Rank : 1558 / 11873

1.
第一題簡單寫，先把原本的字串用" "做拆分，每拆一個字出來，就去檢查它的prefix是否為searchWord，找到一個就直接return，如果最後都沒找到就return -1
複雜度O(n)，n為原本字串的長度，每個字最多看兩次，一次是在拆分，一次是在比對

2.
第二題造一個長度為k的moving window，並計算裡面的母音數量，每次往右移動一格，並扣掉最左邊的字元
用一個unordered_set存所有的母音，讓查找母音為O(1)，不斷更新moving window裡最多的母音數量
複雜度為O(n)，n為原字串的長度，每一個字元最多看一次

3.
直接做tree traverse，每經過一個點就累加出現的數字數量，到leaf的時候再判斷是否可以構成迴文
可以構成迴文的條件是，最多只有一個字元為奇數，其他都為偶數
在return前要把自己這個數字的數量減回去，保持只有一條path的數字，如果不是leaf，就遞迴左子樹跟右子樹(如果有的話)
複雜度為O(n)，n為node的數量，因為每個點只會看一次，判斷迴文的地方是O(1)

4.
第四題一看就是遞迴，結果一開始遞迴的定義設錯，多傳了三次...
定義dp[i][j]為以num1第i個和num2第j個為最後，可以得到最大的dot product
所以dp[i][j]就有四種可能，不使用i，不使用j，使用自己且使用dp[i-1][j-1]，或是只使用自己
其中如果dp[i-1][j-1]為負數，就一定不會使用
整個遞迴式其實就有點像是lcs，最後就return dp[m][n]
複雜度為O(mn)，m和n分別是兩個陣列的長度
好久沒有破台了，最後一題其實沒有很難但想太久...
