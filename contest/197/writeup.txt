Rank : 3113 / 13983

1.
第一題沒什麼好說的，直接爆搜所有可能
複雜度O(n^2)，n是陣列大小

2.
第二題我們就在原字串中找連續的1
對於k個連續1，總共有(k+1)*k/2種substring(這裡要注意先轉成long long，不然會溢位，比賽傳錯一次)
最後把所有可能加起來就好，過程中不斷做mod
複雜度O(n)，n是字串長度

3.
第三題比賽的時候我用Dijkstra，結果各種超時，完全不知道問題在哪...
最後看大家都用BFS(其實很像Bellman-Ford)
首先我們先重建edge，用adjacency list存下來
之後開一個queue放之後要走的點，先把start放進去，並初始化機率為1
之後對於每一個和當前點相連的點，我們都去看看更新後的機率會不會比較大(relax)
如果可以比較大，那就更新最佳值，同時把這個點放進queue中
最後當queue為空時就可以return答案
複雜度O(VE)，V是節點數，E是邊數

4.

