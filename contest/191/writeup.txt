Rank : 3074 / 13283

1.
第一題以前遇過，最大的乘積一定是原陣列最大的兩個數或最小的兩個數(如果都是負)相乘，所以簡單sort一下，return前兩個或後兩個乘積的最大值
複雜度O(nlog)

2.
第二題也是簡單寫，先把原本兩陣列sort，接著我們就traverse兩個陣列，把切割出來的最大長跟寬記下來，相乘就是答案
因為乘起來會爆所以先轉成long long，mod之後再轉回int就是答案
複雜度是O(nlogn + mlogm)，n和m為原本兩個矩陣的大小

3.
第三題搞了我老半天...比賽就這樣炸了...再不專心啊我......
一開始想的方法是dfs，從端點節點走向0，但後來發現問題是走到中間可能會不知道該往哪裡走
最後的做法是反過來走，因為0是個路徑都要走到的，所以我們從0出發，然後bfs走到所有節點
首先我們存一下每個節點所有連接的點和out link的點
對於當前節點，如果相鄰的節點沒有一個out link走到自己，代表我們要把這個link轉換一下，cost加1
traverse所有的點就是答案
複雜度O(n)，n是點的個數，其實原本複雜度是O(V+E)，但是因為這題E = n - 1，且V = n，所以其實就是1次方

4.
該死的數學題，完全不想想...
