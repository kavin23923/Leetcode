Rank : x / x

1.
第一步先把數字跟符號分成兩個字串，接著判斷兩個字串長度是不是最多只差1
是的話就可以直接造答案，兩個字串輪流使用，最後把多出來的加在前面或是後面
複雜度O(n)，n為原字串長度，每個符號看兩次

2.
第二題題目看超久也不知道是什麼演算法...
首先先用一個set把所有食物存下來，而set已經幫我們做好順序
接著用一個unordered_map做food和table entry的對應，方便最後累加答案
接著再traverse原本的陣列，把對應的table和各種食物的累加用一個map存下來，這裡map也幫我們把桌順排好了
最後traverse map，把數字都轉成string，就是答案了
複雜度為O(nlogn)，因為set和map的操作都是O(logn)

3.
第三題寫法有點暴力，開一個vector分別存五個字元的次數
每看一個字元的時候，都檢查他前面所有的字元是不是次數都大於它，否則就不會是合法的字串，然後再累加次數
而需要的frog數為第一個字元-最後一個字元，因為最後一個字元代表有多少已經完成了，剩下的都是新的frog，不斷的更新最大的差值
最後特判是不是每一個字元出現的次數都是一樣的，是就return答案，否則也不是合法字串
複雜度為O(n)，每一個字看一次

4.

