Rank : x / x

1.
第一題看半天，發現題目有講是給定一個balanced string，那就可以greedy的做
一直計算現在左和右的數量，如果當前位置的左右數量一樣，就可以以當前位置為分割點，答案++
因為題目的限制，提早切一定可以保證答案最大化，因為切完後面還是balanced string
複雜度O(n)，n為字串長度

2.
第二題如果用queen來看會有點麻煩，但反過來以king為起點，往它的八個方向走
看看當前方向有沒有queen，且一個方向最多找一個就好
先初始化棋盤，有queen為1，沒有為0
之後就個別往八個方向走，一直走到出界或是有queen，然後同時更新答案
複雜度為(n^2)，這裡的n其實為8，但寫n比較容易看

3.
第三題dp，寫了我大概40分鐘...跪了
定義dp[i][j][k]為長度為i、最後為j且連續長度為k的次數有幾次
接著就開始更新dp，分為兩部分，一個是k為1，一個是k=2~i
如果k為1，則這個答案可以為長度減1、尾數為其他數字且任意連續次數的總和（注意連續次數不可以超過15，因為最長就是15，這裡比賽沒注意到，傳錯一次）
如果k為其他數字，則這個答案基本上為長度減1、尾數為同一個數字且連續k - 1的值，但要符合題目各數字最多連續長度，超過就為0
然後k為1特判一下，因為一開始初始化整個陣列為0，所以相加肯定為0，但一開始長度為1，各數字為結尾且長度為1至少都會有一次，所以如果為0就把它轉成1
最後我們把長度為n，所有的組合都相加就是答案，過程中用long long存且不斷做mod
複雜度為O(n*6*6*n)，大概可以看成O(n^2)

4.
第四題比賽沒寫出來，其實連題目意思都搞錯...
這裡我們用兩個vector分別代表數字出現的個數，以及各個個數的頻率
接著就開始看每個數字，只有兩種可能是我們要的
第一種是當前數字的個數*這個個數的頻率=目前數字個數，則把下一個數字去掉，一定符合題目要求，所以答案等於目前數字數量+1（且還要有下一個數字）
第二種是目前數字個數-當前的數字的個數*這個個數的頻率等於1，或者是這個剩餘的數量為當前的數字的個數+1，且頻率為1，則我們拿掉一個數字全部的次數都是相同的
所以答案為目前數字數量，最後回傳最大就好
複雜度為O(n)，n為陣列大小，因為one pass就搞定了
