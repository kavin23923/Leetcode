Rank : 1790 / 12353

1.
第一題簡單寫，開一個unordered_set先把所有目標城市加進去，再把所有出現在起點的城市拿掉就是答案。
複雜度O(n)，n為path的個數

2.
第二題也是簡單寫，紀錄上一個1出現的位置，然後跟目前1的位置比，如果小於k就return false，可以跑完就return true
複雜度O(n)

3.
第三題一看就知道要用two pointer寫，但是一開始想錯移動的條件所以搞很久
為了維護範圍內的數字大小，開一個map，記錄每個數字出現的次數，用map的原因是本身就有順序性，我只要看map的頭跟尾就是最大跟最小值
然後我們就一直增加右界，直到加進去的數字破壞了規則，再來就移動左界，直到保持題目的限制，移動左界的時候還要順便維護map
最後就用左右界的位置更新答案
複雜度O(nlogn)，因為每次操作map複雜度為O(logn)

4.
第四題比賽的時候想錯方向沒寫出來，
最後用的方法是一次加一排，用一個max heap保持順序性，且大小最大為k
之後的每一排，對每一個數字都和heap裡的東西相加再放進heap中，數量超過k就pop出來
最後heap的最上面就是我們要的答案，因為下面的東西都比top小
複雜度為O(m*n*klogk)，其實有更好的方法，但是我看不懂那個思路...
