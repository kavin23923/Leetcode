Rank : 4530 / 13808

1.
第一題簡單寫，直接照題目的意思把每一個數字造出來，然後xor在一起
複雜度O(n)，結果這是我整場比賽寫出來的唯一一題...

2.
這題比賽的時候直接放生，被下一題搞到心態炸裂直接沒寫，不過我也不見得寫得出來
這題難在我沒想到要怎樣馬上判斷一個字串下一個可以用的數字是多少
拆字串也有點麻煩(其實反過來合字串就比較簡單)
題目的example5讓我有點混淆
最後的解法是開一個unordered_map，key是出現過的字串，value是下一個可能的數字
每看一個字串時，都去檢查是否出現過，如果沒有就沒事，順便把它塞進map裡
如果有，那就先把數字拿出來，然後開始窮舉，看看"字串+(數字)"有沒有出現過
有就加數字繼續找，沒有就停下來
最後要更新兩個東西，第一個是把字串+新的數字放進去(搞定example5)
第二個是更新本來的entry的數字，變成現在的數字+1
複雜度是O(n)，n是names的個數，因為字串長度最長是20，所以看成是常數

3.
第三題在比賽直接傳爆，其實看了解答我在比賽應該還是寫不出來，因為我不會用upper_bound
這題難在目前有的dry沒辦法知道要解哪一個lake，必須根據後面的來判定
更麻煩的是，每一個dry能更新的就只有自己前面的lake(這個性質讓我gg)
解法是開一個unordered_map，記錄每一個lake以及他的位置
再開一個set，存下每個dry的位置
接下來就traverse input，如果是dry，那就把位置放進set，並暫存答案為1
最後不是1也無所謂，反正會被蓋掉，沒被蓋掉的代表不重要，隨便填都行
如果是lake，那就看這個lake有沒有出現過，沒有就暫時不用管他
如果有，那就把他前一個位置找出來，再去set中看第一個大於他位置的dry，用來蓋掉他
如果沒有就直接return空陣列，有的話就更新那個dry的答案，並從set拿掉
複雜度O(nlogn)，因為set的操作都是O(logn)，第一次比賽只寫出一題easy，簡直哭...

4.

