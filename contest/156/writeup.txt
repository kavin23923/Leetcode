Rank : x / x (去年比大概40%，今年virtual contest大概10%，這九個月進步不少啊!!!)


1.
第一題頗簡單，先用一個unordered_map計算每一個數字出現的次數，再traverse map
用一個unordered_set記錄每一個次數是否有出現，有就return false，可以跑完就return true
複雜度O(n)，n是數字的個數

2.
第二題一看就是moving window，記錄一個目前可以的範圍
一開始先移動右界，一直到超出題目的限制，同時更新最佳解
再移動左界，直到符合題目的要求
比賽的時候傳錯兩次，一次是自己犯蠢，另一次是邊界條件沒寫好
考慮答案在最後面，更新右界到底時cost沒超過但是邊長已經超過了，則跑不到while裡面的更新
所以最後特判一下，如果跳出while之後的cost是合法的，那就再更新一次
複雜度O(n)，n是字串長度

3.
第三題稍微想了一下，決定用類似stack的想法去做，並開一個vector來記錄目前答案每一個位置的重複次數
對於每一個字，如果他跟答案最後一個字一樣，且上一個答案加一剛好是題目的限制k
那就要把答案後面k-1個重複的東西pop掉，並還原vector的值
如果不是這種情況，則把當前字元加進去答案中
如果這個字元跟答案最後一個字元相同，就更新vector的值為最後一個加1
最後剩下的字串就是答案
複雜度O(nk)，n為字串長度

4.
完全不知道在幹嘛的一題...那個題目的走法限制我是看別人的答案才推敲出來的...
看到走路題+最短路徑，使用bfs
用一個set去紀錄走過的位置(因為位置是一個vector，所以不能用unordered_set，好像需要一個特殊的init)
再來開一個queue，紀錄可以走的位置，先把起始點放進去
然後就是開始走bfs，如果當前已經是答案就return答案
不然就開始看能不能旋轉，旋轉有很多限制
像是要平行的才可以往下轉，且下面兩格都要是空的
要是垂直的才可以往右轉，且右邊兩格都要是空的
再來就是往下或往右走，這裡不管是哪個方向都可以
接著就一路走到終點或是不能再走
複雜度O(n^2*logn)，因為每個點最多走一次，但每一次操作都是log複雜度
