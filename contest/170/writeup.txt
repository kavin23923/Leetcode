Rank : 1751 / 6833

1.
第一題稍微想了一下，如果當前的字串是1 or 2，那我們就看他是不是有後面的'#'
沒有的話直接轉字母，不然就連同後面的數字一起轉成字母
複雜度O(n)，n是字串長度

2.
第二題滿簡單的，用的是比賽常見的累加和技巧，只是這裡是xor
首先我們先改寫原本的陣列，將第n格的含義變為從0~n xor完的結果
最後對於每一個query，我們都可以在O(1)複雜度查找，
(left, right) = arr[right] xor arr[left - 1] 因為自己xor自己為0
複雜度為O(n + m)，n是陣列的大小，m為query的數量
 
3.
第三題花了很多時間，因為一開始我的做法是dfs，但這樣的順序會有問題
後來改用queue實作bfs，其實滿可惜的，因為看到最短路徑就應該要想到用bfs
首先用一個unordered_set紀錄哪些點出現過
再來就是bfs的實作，每次都加入沒看過的朋友，當level層都做完，最後還在queue裡的就是答案
先用unordered_map去計算總和，接下來為了要符合題目的順序，用一個set<pair<int, string>>
因為pair本身會照第一個參數由小到大，再照第二個參數由小到大排列
因此把東西放進set中，讓set照著pair的順序排序，最後在traverse set把字串放進答案裡
複雜度為O(n^2)，n為總人數，這個複雜度為bfs本身的複雜度，因為每個點最多看一次
而level可能可以讓這個複雜降低，因為不用看完所有點，而最後sort跟搬來搬去的操作都是O(nlogn)