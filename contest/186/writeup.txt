Rank : 2836 / 11684

1.
第一題easy我竟然寫了10分鐘...
第一輪先用一個陣列紀錄到第n個位置出現幾個0
第二輪直接窮舉所有位置，計算左邊的0(by上面的陣列)+右邊的1(右邊全部的數量-0的矩陣)的最大值
複雜度O(n)，那個右邊的1寫老半天才寫對...

2.
第二題的概念跟上一題差不多
用兩個矩陣分別紀錄prefix和suffix sum
最後就是窮舉k+1種可能，前面抓0~k個後面抓剩下的數量，再記錄最大值
複雜度O(n)

3.
第三題比賽的時候先是超時，最後想出方法了，但來不及寫完，出門買午餐才想出來怎麼寫...(感謝LiBo Orz)
一開始的想法是先爆左邊那排，再爆下面那排，一次往左上角移一格，超時
後來想一想，其實每一輪就是照順序拿，如果那排還有數字沒拿出來，那就可以拿，否則直接跳下一排，這樣就不會有多餘的操作
所以開了一個set去紀錄目前照順序可以拿哪些排，再用一個vector紀錄每一排拿到哪
如果發現當前這排已經拿完，則我們就可以把這排從set中拿掉
但是比賽的時候發現這樣WA，原因是traverse set時，如果直接把iterator某格拿掉，再it++，會跳過一排
最後想到mentor的招數，先記下下一輪iterator的位置(用next)，就可以隨便刪了，我這個菜雞...
然後就是一樣先爆左邊那排，最後就每次都從最下面那排出發，直到set裡面沒有任何東西
我的set是用相反的方向，這樣第二輪就可以一直從begin開始
複雜度O(nlogn)，n是矩陣內數字的數量，因為用set traverse每一次都是O(logn)，且每個數字只會看一次
比賽的時候完全沒看到"There at most 10^5 elements in nums"這句話...

4.

