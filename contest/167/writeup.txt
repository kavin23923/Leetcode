Rank : 1164 / 5453

1.
第一題輕鬆寫，traverse linked list順便把數字轉成10進位
一開始遇到奇怪的bug，使用以下寫法
decimal = decimal << 1 + head->val;
這樣寫答案會一直是0，原因是'+'的運算優先於'<<'，所以會先算1+head->val，最後怎麼shift都會是0
最後直接換成*2，不然就是把'decimal<<1'給括起來
複雜度O(n)，假設有n的node

2.
第二題就是窮舉所有的可能，對於在low~high之間的數字
假設low是m位數，high為n位數(m, n可以相等)
窮舉每一個位數長度的可能
窮舉的方式是先準備'add = 111...(k位數)'和'now = 123..(k位數到k)'
然後就一直把add加到now，看這個數字是不是界在low~high之間，
特別要注意的是如果最後一個數字已經是9了，就要break迴圈
因為如果high處於更高位，那再往上加還是可能界在low~high之間，但是已經不符合題目的要求了
比賽的時候第一次傳有overflow，發生在'now += add'，後來解決辦法是只要數字大於9位數就不用再處理了
因為10位數不可能符合題目的需求(第六行的min)，也就不會有overflow的問題
複雜度大概是O((n - m)*n)，總共要窮舉n - m位數，其中每次的prepare最多要花n次迴圈
但每次實際處理最多跑9次，因為加10次一定會break迴圈

3.
第三題一看就覺得是DP，想法是我要很快的知道某一個正方形的總和是多少再窮舉
所以先用累加和的方式重新建造矩陣
後來發現外圈再多一層都為0的(DP常見的作法)會更好操作
最後對於某一格(x, y)，窮舉所有左上對角線的點就可以知道以(x, y)為右下角點的正方形面積為多少
再來更新最長的邊長
複雜度是O(n^3)，n為原矩形的最長邊
這個做法感覺可以再優化，既然都用DP了，感覺可以把複雜度壓在O(n^2)
不過比賽的時候算了一下覺得三次方應該可以過，就直接用了

4.
