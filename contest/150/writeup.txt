Rank : x / x

1.
第一題簡單寫，先用一個unordered_map紀錄chars裡每個字元出現的次數
接下來看一個字串，看看他擁有的是不是都被chars給包含，是的話就把字串的長度加到答案裡
複雜度O(nk)，n是字串的數量，k是字串的平均長度

2.
第二題也很簡單，看到level order traverse直接用bfs搞定，紀錄每一層的總和，同時更新最大值，並往下層遞迴
複雜度O(n)，n是樹的節點數量，因為每一個點只會走一次

3.
第三題跟上一題一樣，都用bfs去做，首先traverse一下原本的矩陣，把是1的位置放進queue中
這裡特判一下，如果全都是1 or 全都是0就直接return -1
接下來就往外走，每一次都把4 connected為0的格子加進去，再把這些格子設為1，接著一直走到整個grid都是1為止
進行的回合數就是答案
複雜度O(n^2)，n是矩陣的大小，因為我們只會走整個矩陣兩次

4.
第四題比賽的時候只寫了一個O(n^2)的方法，果然超時
最後的解法是，我們使用兩個頭，然後用兩個頭+長度來判斷
如果兩個字元是一樣的，那就長度加1繼續
如果第一個比較小，那就用第二個取代第一個，然後第二個加1
如果第一個比較大，那第二個+長度都可以直接跳過，因為保證不會比第一個大(否則前面早就被更新了)
最後return以第一個位置為起始點的substring就是答案
複雜度O(n)，因為第二個+長度保證只會走一次
