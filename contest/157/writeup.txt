Rank : 58 / 5435 (virtual contest又差不多1%了，記錄一下XD)

1.
第一題很簡單，直接爆搜所有可能，以每一個chip為終點，看每一個chip和它的距離，如果距離為偶數就沒有cost，奇數就加1
最後找到最小的cost總和就是答案
複雜度O(n^2)，n是chip數，有另一個加速法是，紀錄曾經出現過的位置，因為題目說位置可能會重複

2.
第二題看一堆人傳錯有點慌，結果輕鬆搞定- -
用一個unordered_map紀錄以每一個數字為結尾，最長的sequence為多長
接著就traverse原矩陣，如果它的diff target有在map中，則長度為target的答案+1，不然就為1
接著我們更新最佳解，以及以當前數字為底的最長sequence（所以用max）
複雜度O(n)，n為陣列大小

3.
第三題標準dfs，看到都開心
對於每一個非0的格子，都跑一次dfs，最後回傳最佳解
而dfs則是走到不能再走為止，每一次把當前的格子改為0（避免重複走），再繼續走，走到底就更新最佳解，dfs return前要把格子改回來
複雜度(mn * mn)，因為每個格子都可能為起點，且每一次最多走一遍全部的格子，m和n為原矩陣大小

4.
第四題是很簡單的dp，定義dp[i][j]為長度為i，且最後一格為j字元的組合有多少(依序為a, e, i, o, u，a為0，e為1，依此類推)
初始化長度為1的時候都是1
接著就開始跑dp，按照題目給的條件，舉例來說，a因為可以在e,i,u後面，則當前答案就會是那三個的前一個答案相加
加的過程中持續做mod，最後把長度為n的五種情況相加就是答案
複雜度O(n)
