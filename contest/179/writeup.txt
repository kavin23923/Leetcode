Rank : 926 / 6242

1.
第一題簡單寫，先造一個有n個a的字串，如果發現字串長度是偶數，就把最後一個字元改成b
複雜度O(n)

2.
第二題題目在問的其實是，當我們在monent k時，1~k+1都必須要存在
所以開兩個數字紀錄目前看過的最小跟最大值
每一輪看過一個數字後就更新那兩個數字，再判斷條件(small為1且small~big的長度剛好為k+1)
如果是的話這一輪所有燈都會是藍色
複雜度O(n)

3.
第三題是基本level order traverse的題目
先把subordinate關係整理好，之後就用一個queue，從head開始一層一層traverse
同時更新目前最長的時間
複雜度是O(n)，因為整個樹最多就是n - 1的edge，每個edge只會看一次

4.
第四題可能有更好的解法，但因為n不是很大，所以就簡單實作一個方法
首先先把每個點連接的點整理成一個vector to vector
再來還是使用一個queue，每一round是(id, path) pair，記錄目前的點以及走過的路徑
當我們走到目標點時就知道已經找到路徑了，不然就根據vector traverse所有可能的路徑
最後根據路徑長度跟t考慮三種情況：
1. 如果路徑長大於t，則機率一定為0
2. 如果路徑長等於t，則直接根據每一個點走的機率計算答案就好
3. 如果路徑長小於t，要多考慮兩種狀況：
3a.如果最後一個點剛好是tree head，則和它連接的點數必須為0
3b.如果不是tree head，則連接點數必須是1 (走過來的那個點)
如果不是以上這兩種情況，則下一跳之後就會跳離target
因為第三個case一開始沒有想清楚，最後多傳了兩次
複雜度是O(n)，因為每一個邊只會看一次，且總共只有n - 1個邊
