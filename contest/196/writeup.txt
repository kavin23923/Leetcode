Rank : 6571 / 14301

1.
第一題如果要符合題目的條件，唯一的可能就是sort之後兩兩的差距相等
所以簡單的把原矩陣sort後兩兩相比，如果有一對的差距跟其他不一樣直接return false，全部走完就return true
複雜度O(nlogn)，n是矩陣的大小

2.
第二題比賽搞半天，原來是題考智商的...
如果兩隻螞蟻相會要轉向了，則下一個時間點其實就跟兩隻螞蟻照原本的方向繼續走一樣
根本不用管是哪隻螞蟻
所以題目其實可以簡化為，所有螞蟻裡距離邊緣最遠的距離...結束
複雜度O(m+n)，m和n分別為left和right矩陣的大小

3.
第三題一看就是dp，然後我的dp恐懼症又發作了...
這題如果不做pre-compute，則複雜度會是O(m^2*n^2)，說不定也會過
但我們可以先開一個dp預處理，dp[i][j]代表的是第i個row第j個col包含自己右邊有多少連續的1
所以如果原矩陣(i,j)是0，則就是0，否則就是右邊的值+1
之後就可以開始算答案，我們用(i,j)這個位置當作最左上角，看看可以有多少個矩形，這邊的複雜度是O(mn)
對於每一格，我們都往下去找，因為右邊有多少1都已經知道了，就可以不用往右走了
而每往下走row，我們都去計算dp的最小值，代表截至該row為止，可以有多長的矩形，然後加上去就好
總複雜度O(mnm)，m和n分別是矩陣的row和col，因為每一格我們都要走過下面全部的row

4.

