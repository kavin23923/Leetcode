Rank : 2664 / 13661

1.
第一題直接暴搜窮舉所有可能，用find看是否存在substring的關係，然後存在一個set裡(因為一個字串可能為多個字串的substring)
複雜度O(c*n^2)，n為字串數量，c為使用find的一次常數，因為input最長30，可以用一個常數表示

2.
第二題也是直接暴力解，用一個stack模擬原本的陣列，再開一個額外的stack暫時存放拿出來的數字
每一輪都去找目標的數字，找到之後先把它拿出來，剩下的東西丟回去之後，再把目標放在最前端
最後就可以輸出每一輪目標的位置
複雜度是O(m^2)，因為每一輪搬來搬去最多會花O(2*m)的時間

3.
第三題不知道在幹嘛，也是暴力解...
原本的字串一個字元一個字元看，如果不是&就可以直接加進答案裡
如果是&，那我們就看後面的若干字元是不是題目要的，然後分別用if和substr做判斷...
是的話就替換，不是的話就把&加進答案裡，繼續看後面
複雜度O(n)，n為字串長度，其中做了六個substr的判斷，但是因為長度都是固定的，所以不影響最後的複雜度

4.
第四題一看就是dp，最後還是沒解出來...
本來的想法是一格一格看，但遞迴式想不出來
最後的做法其實是一排一排看
考慮每一排，如果是三種顏色都用，那只會有六種可能。如果是只用其中兩種，那也是有六種可能
而每一排其實只會受到前一排影響
最後，假設我們這一排是三色，則下一排可以有兩種三色和兩種二色的可以使用
假設我們這一排是二色，則下一排可以有兩種三色和三種二色的可以使用
初始化第一排為六種三色六種二色，最後就用for跑到第n排就好，中間一直使用mod做運算
複雜度為O(n)，只能說，這一題是所有寫起來最簡單的...但我想不到...
