Rank : 2347 / 8106

1.
第一題應該有更好的方法，但我看一下複雜度會過就不去想了
一層一層遍歷，如果當前的entry已經是負數，則整個row剩下的部分都會是負數
複雜度為O(n^2)

2.
第二題傳了兩次，想說暴力解看看會不會出事，果然太天真了...
正確是思路是用類似累加和的方式去做
對於add，我們紀錄最後一個為0的位置在哪，如果前一個數字是0，則下一個數字累乘重新開始計算，否則就是上一個數再乘input
對於get，考慮k和最後一個0的位置(zero):
1. 如果k在zero前面，則累乘一定包含一個0，直接return 0
2. 如果k剛好為zero，或k剛好就是全部的數字，則直接return最後一格（因為不能除0）
3. 如果k比zero後面，表示累乘不包含0，則直接return最後一格除以k那格
不管是add or get，複雜度都是O(1)

3.
第三題比賽的時候知道要用greedy，且每一輪應該要拿end最早結束的，但不知道怎麼同時考慮start和end（不考慮start則不是最佳解）
最後的思路是，先對start做sort，之後maintain一個heap，順序是照end sort
使用一個變數d紀錄目前最早可以使用的time slot，如果目前heap為空，則以下一個event的start為d
每一輪我們都加入目前這個d可以加的event，然後從heap中拿出一個並更新d，最後再根據新的d來踢除heap中已經不能使用的event
直到heap和event全都看完，最後就是答案
複雜度是O(nlogn)，n為event數
