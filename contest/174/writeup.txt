Rank : 1365 / 6997

1.
第一題簡單寫，用一個heap來維持順序，最後再拿出k個element
複雜度為O(mn + klogm)（應該可以再降，heap裡其實只要維持k個element就可以了）

2.
第二題用跟上一題差不多的方法，先計算每一個數字出現的次數，再把數字跟次數倒進heap裡
每次拿出數量最多的那個，不斷檢查剩下的數量是不是只剩不到一半
複雜度為O(nlogn)，n為數字的個數，worst case是vector裡每一個數字都不一樣

3.
第三題認真想了一下，如果那個乘績要是最大的，那個別的總和越接近所有總和的一半越好
ex: 總和12，則拆成"6+6 -> 6*6 = 36"為最大值
因此直接traverse整棵樹，把每個子樹的總和存起來
最後再traverse所有子數和，最接近全部總和一半的node，就是要切的位置
複雜度為O(n)，n為node個數，因為每一個點最多看一次

4.
第四題比賽的時候有猜到要用dp，但沒什麼想法
賽後去看題目的hint，假設dp[i]代表第i個位置可以走到的數量，則dp[i] = 1 + max(dp[j])，其中j為所有i可以到的位置
看到這個定義就知道怎麼寫了
首先我們先把高度做一個排序，從低的地方開始看，每次都去看左邊和右邊d個位置
如果旁邊的高度小於自己，就不斷更新高度，否則break迴圈
最後當全部的位置都跑完後，max(dp[i])就是答案
複雜度是O(nlogn + nd)，d最大和n同量級，所以worst cast為O(n^2)
