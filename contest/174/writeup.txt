Rank : 1365 / 6997

1.
第一題簡單寫，用一個heap來維持順序，最後再拿出k個element
複雜度為O(mn + klogm)（應該可以再降，heap裡其實只要維持k個element就可以了）

2.
第二題用跟上一題差不多的方法，先計算每一個數字出現的次數，再把數字跟次數倒進heap裡
每次拿出數量最多的那個，不斷檢查剩下的數量是不是只剩不到一半
複雜度為O(nlogn)，n為數字的個數，worst case是vector裡每一個數字都不一樣

3.
第三題認真想了一下，如果那個乘績要是最大的，那個別的總和越接近所有總和的一半越好
ex: 總和12，則拆成"6+6 -> 6*6 = 36"為最大值
因此直接traverse整棵樹，把每個子樹的總和存起來
最後再traverse所有子數和，最接近全部總和一半的node，就是要切的位置
複雜度為O(n)，n為node個數，因為每一個點最多看一次

