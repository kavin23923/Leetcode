Rank : x / x

1.
第一題一開始想說搞個比較漂亮的做法，結果傳錯一次...
最後直接硬報，窮舉所有可能，寫一個function回傳一個數字有沒有包含0
接著窮舉n拆成兩個數字，只要其中一個兩個數字回傳都沒有0就是答案
複雜度是O(nlogn)，因為對於一個數字，驗證是否有0需要O(logn)的時間

2.
第二題也是簡單寫，直接把三個數字拆成binary的形式，然後先把三個vector變成一樣大小，方便最後操作
之後就每個bit看，如果c是0，那a和b出現一個1就要把答案加1，如果c是1，則除非a和b都是0就要再把答案加1，不然就沒事
最後回傳答案就好
複雜度是O(logn)，n是a, b, c轉成二進位後最長的長度

3.
第三題寫起來很順暢，dfs題目，首先先想，如果要連接n個電腦，其實只需要n-1的edge，所以我們先特判一開始的邊是不是有n-1條，有的話一定可以連起來，不然直接return -1
接下來，先把原本的connections存成adjacency list，然後dfs看看原本的連接會把所有電腦接成幾個部分
如果全部只有1個部分，代表已經全部連在一起了，反之如果有2個部分，代表只要把其中一個部分裡多出來的邊(一定會有多的邊)將兩個部分連起來就行
所以最後的答案其實是"分成幾個部分-1"
複雜度是O(n+m)，n是電腦數量，m是connections的size

4.
第四題是dp...直接裝死Orz
