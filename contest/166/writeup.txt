Rank : x / x

1.
第一題直接把數字弄成digit分解
分別計算product和sum，再return兩個相減
複雜度是O(logn)

2.
第二題開一個unordered_map存group size和目前各組內容的對應
首先先將當前數字放進對應的group size的vector中
如果發現這個vector的size剛好跟group size是相同的，代表已經找到一組了
就把這組放進答案中，再清空這個vector
複雜度是O(n)

3.
第三題標準binary search題目，左界為1，右界為原input的最大值
用一個function判斷目前一個數字有沒有符合threshold的條件
binary search找最小且符合的就好
複雜度O(nlogn)，因為每一次的判斷是O(n)

4.
第四題看到題目的限制發現矩形最大就是3*3，算了一下暴力解的複雜度大概是O(n!)，也就是9!，只要好好寫應該不會超時，就直接硬爆了
因為每一格最多被翻一次，反兩次等於沒有翻，所以我們直接窮舉翻的位置的排列
用一個unor ssdered_set紀錄走過的點，並用一個數字zero計算目前矩陣0的數量，這樣就可以在更新後用O(1)的知道目前的矩陣是不是已經是答案了
對於翻每一格，我們都去看更動自己且4個鄰居之後zero的數量，並記一下改動的位置，方便之後遞迴完改回來
如果是的話就可以更新最佳答案並直接回傳，否則就繼續遞迴，最後回傳答案就好
結果寫的時候各種出現問題，什麼index算錯，遞迴完沒有把東西恢復原狀之類的...
最後還做了一下剪枝，如果目前改過的點已經沒有比最佳的答案還少，就可以直接return，加了這個之後3*3的就可以過了
複雜度O((n*m)!)，m和n分別為矩陣的長寬
