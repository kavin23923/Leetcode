Rank : x / x

1.
第一題簡單寫，開兩個陣列，分別代表每個row和col各被加過幾次
之後窮舉每一格，值為該row+col的值，如果這個值是奇數，就把答案++
複雜度O(mn+k)，m和n為原矩陣的大小，k為indices矩陣的長度

2.
第二題一開始卡了一下，改先寫第三題才回來，而且最後還傳錯一次...
這題我們用two pass
第一個pass，我們先考慮colsum為2的情況，則上下都一定要為1，那我們就把答案填上去，再把upper跟lower--
這個pass結束後我們看這兩個值是不是都還大於等於0，不是的話就直接return空矩陣
第二個pass，我們就看colsum為1的情況，如果upper大於0，我們就把1放上面，否則如果lower大於0，就把1放下面，再不然就return空矩陣，因為已經沒有可以用的了
最後再回傳答案前特判(傳錯少了這個判斷)，upper和lower都必須要為0，不然還是要回傳空矩陣
複雜度為O(n)，n為colsum的長度

3.
第三題基本dfs，我們也是用兩個pass，每次dfs都走周圍4個方向的0，並把0改成1，這樣就不會重複走
第一個pass我們先跑邊緣的0，因為這些邊緣相連的0不符合closed island的定義
第二個pass，看看有多少還是0的格子，每次都跑一次dfs，並把目前有的數量+1，最後回傳數量就好
複雜度O(nm)，m和n為原矩陣的長寬，因為每個點我們只會走到一次

4.
第四題算是很簡單的hard，首先先看一下input大小，words最多就是14個，對於每個字就是選或不選，所以在暴搜的情況下，基礎複雜度是O(2^14)，還很小
只要我們把中間的操作寫好，一定不會超時
接下來我們把letter和每個word都存成一個大小26的vector，方便之後操作
然後就開始暴搜，對於每一個字，我們都可以選或不選，如果選了，就更新一下每一個char的次數，然後就一直遞迴下去
最後到底的時候就判斷這個組合是不是合法的，是的話就return score，然後同時更新最佳值，就是最後的答案
複雜度是exponential time，但因為每一輪的操作都是O(1)，所以沒問題
