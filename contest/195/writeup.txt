Rank : x / x

1.
第一題很簡單，基本上就是看目前的位置有沒有走過
我把走過的位置用'#'符號隔開，弄成一個string放進unordered_set中
接著就是走過一遍題目的字串，如果過程中走過了之前走過的點就return true，全走完就return false
複雜度O(n)，n字串的長度

2.
第二題是兩兩配對題，想法是用一個unordered_map紀錄mod k後各種數值的數量
然後就可以知道是不是全部可以湊成對
特別注意負數，因為C++下負數mod不會是我們想要的界在0~k-1的結果，所以我選擇先把負數轉正再處理
之後就traverse map，分成三種情況
如果mod後是0，則這個區間要跟自己配，所以看數量是不是偶數
如果mod後是k / 2，也是跟自己區間配，所以看數量是不是偶數
第三種情況就是mod完是a，則看mod完是k - a的數量和自己一不一樣
其中一種不符合就是false，反之跑完就return true
複雜度O(n)

3.
第三題的解法是two sum，我有想到用sort但沒想到用two sum去解...
看來我對two pointer的解法還是不夠熟練
首先我們先把2的次方都算出來，這個我也沒想到，比賽的時候還在想要怎樣快速知道2的任意次方
答案是先算好就好...
接著就開始走two sum，如果當前範圍符合要求，就更新左界，反之就更新右界
而區間內的subsequence可以用之前算好的vector快速求出
因為對於每一個數字(除了第一個)，都可以是有或沒有
最後把答案加起來就可以，但小心不要overflow...
複雜度O(nlogn)，主要來自sort

4.
這題的標準解是用heap，複雜度會變成O(nlogn)，但是可以用deque優化成O(n)
先看題目的公式，因為x越來越大，所以原式子會變成yi+yj-xi-xj=yi-xi+yj-xj
首先我們用pair存每一個點，分別為(y-x, x)，把可能可以的放在deque中
同時我們還要保持deque裡的y-x為遞增的，這樣deque的頭就會是目前最佳解
之後對於每一個數字，先把和當前x距離超過k的拿掉
如果deque裡面還有東西，則答案就會是頭跟現在的點的組合
之後從最後面開始看，如果最後的y-x比自己小，就把它拿出來，一直到可以維持遞增為止
(因為前面的x如果在k的範圍內，則當前的點也會在，而且得到的答案更好，所以可以捨棄最後一個)
一直更新最佳值就會是最後的答案
複雜度O(n)，n為點的數量

